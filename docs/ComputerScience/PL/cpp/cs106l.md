---
    comments: true
    statistics: true
---

# CS106L

!!! info 
    速通 CS106L 2024 Autumn 之后记录的粗略的笔记，主要来自于课程的 slides，一定程度上也是对我的 [C++笔记](/docs/ComputerScience/PL/cpp/cpplearning.md) 的补充。

    CS106L 的 slides 和 assignments 解答可以在我的仓库 [CS106L-2024-Autumn](https://github.com/xestray/CS106L-2024-Autumn) 中找到。

## 类型与结构体

### 类型

C++ 是**静态类型语言**，在编译时就需要确定每个实体（变量、函数等）的类型，并且它们的类型从被定义之后就不能改变。

**动态类型语言**（如 Python）在运行时才会确定类型，并且在**运行过程中**会不断根据它们当前的值来确定类型。

### 结构体

结构体（struct）是一种用户自定义的，由多个成员变量组成的数据结构。它可以作为函数的参数、返回值，也可以作为容器的元素，从而实现一次传递多个数据。

!!! example "结构体"

    ```cpp
    struct StanfordID {
    string name;    // These are called fields
    int idNumber;
    };

    // Initialize struct
    StanfordID id1;                  
    id.name = "Xestray";    // Access field with ‘.’
    id.idNumber = 114514;

    // List Initialization
    StanfordID id2 = {"Xestray", 114513};
    ```

### std::pair

std::pair 在 <utility> 头文件中定义，是一个模板类，用于存储两个的对象（不一定是相同类型）。可以通过 `first` 和 `second` 来访问其中的元素。

```cpp
std::pair<double, double> point { 1.0, 2.0 };

std::cout << point.first << " " << point.second
```

我们可以直接使用 `std::make_pair` 来创建一个 pair 对象，并使用 auto 来自动推断类型。

```cpp
auto point = std::make_pair(1.0, 2.0);
```

## 初始化与引用

### 初始化

C++ 有三种初始化方式：

- 直接初始化（direct initialization）
- 统一初始化（uniform initialization）
- 结构化绑定（structured binding）

#### 直接初始化

直接初始化有两种形式

```cpp
int num1 = 12.0;
int num2(12.0);
```

C++在直接赋值时不会进行类型检查，这里直接把 double 类型的 12.0 赋值给了 int 类型的变量，会发生窄化转换（narrowing conversion），可能会导致精度的丢失。

#### 统一初始化

统一初始化使用花括号 `{}` 来初始化变量，它可以防止隐式类型转换，也可以避免窄化转换。

```cpp
int num1 {12.0};
float num2 {12.0};
```

12.0 是 double 类型的，因此这里对 `num1` 的初始化会出现编译错误，阻止窄化转换；虽然 `num2` 是 float 类型的，但是因为它们都是浮点类型的数据，double 到 float 的转换是安全的，因此这里不会报错。

统一初始化的优点在于

- 安全性：统一初始化禁止了窄化转换，从而避免出现意料之外的情况
- 一致性：统一初始化可以用于所有类型的初始化场景，包括变量、数组、结构体、类等

#### 结构化绑定

结构化绑定是 C++17 中引入的新特性，允许我们通过结构体、函数的返回值等方式，一次性对多个变量进行初始化。

```cpp
#include <iostream>
#include <string>
#include <tuple>

std::tuple<std::string, std::string, std::string> getClassInfo()
{
    std::string className = "CS106L";
    std::string buildingName = "Thornton 110";
    std::string language = "C++";
    return {className, buildingName, language};
}

int main() {
    auto [className, buildingName, language] = getClassInfo();
    std::cout << "Come to " << buildingName << " and join us for " << className
              << " to learn " << language << "!" << std::endl;

    return 0;
}
```

- 结构化绑定允许我们使用在编译时大小确定的数据结构（如 tuple、pair、array、struct）来一次性初始化多个变量
- 在使用结构化绑定时，我们**只能**使用 `auto` 关键字来自动推断变量的类型

### 引用

引用是某个已经存在的变量的别名，使用 `&` 符号来定义。对某个变量的引用和这个变量的标识符指向的是内存中的同一个地址，因此对引用的操作会直接影响到原变量。

```cpp
int num = 5;
int& ref = num;
ref = 10; // Assigning a new value through the
reference
std::cout << num << std::endl; // Output: 10
```

- 按值传递（pass by value）：函数的参数是一个变量的拷贝，对参数的修改不会影响原变量
- 按引用传递（pass by reference）：函数的参数是原变量的引用，对参数的修改会直接影响原变量

!!! example

    ```cpp
    void square(int& n)
    {
        n = std::pow(n, 2);
    }
    ```

!!! note "左值与右值"

    从字面意思来看，左值就是可以放在赋值运算符左边的值，右值就是只能放在赋值运算符右边的值。但具体来说

    - 左值：是一个具有持久身份、可以取地址的实体，通常对应一个具名对象（变量或引用等）

        - 可以放在赋值运算符左侧（e.g. `int x = 5;`）
        - 有明确的内存地址（可通过 `&` 取地址）
        - 生命周期超过当前表达式

    - 右值：是一个临时的表达式，通常无法取地址，通常对应一个匿名对象或表达式的结果

        - 只能放在赋值运算符右侧（e.g. `10 = a` 非法）
        - 通常是字面量、临时对象或表达式计算结果等
        - 生命周期仅限于当前表达式

## 流（stream）

### 基本概念

**流（stream）**：一种通用的 C++ I/O 抽象，用于读取和写入数据。

- cin：标准输入流，用于读取用户输入
- cout：标准输出流，用于输出信息（无缓冲）
- cerr：标准错误流，用于输出错误信息（无缓冲）
- clog：标准日志流，用于记录非关键事件的日志（有缓冲）

<figure>
    <img src="../assets/CPP_IO库.png" width="70%">
</figure>

#### cout

`std::cout` 流是 `std::ostream` 的一个实例，能将数据输出到控制台上，基本运算符为 `<<`（插入符）。

```cpp
std::cout << "Hello, World" << std::endl;
```

#### cin

`std::cin` 流是 `std::istream` 的一个实例，能从控制台读取数据,基本运算符为 `>>`（提取符）。

```cpp
std::cin >> num;
```

### 字符串流

字符串流（stringstream）可用于处理混合数据类型的情况。

```cpp
int main()
{
    std::string initial_quote = "Bjarne Stroustrup C makes it easy to shoot yourself in the foot";

    // 两种字符串流初始化方式
    // 1. 字符串构造函数
    std::stringstream ss(initial_quote);

    // 2. 插入字符串
    // std::stringstream ss;
    // ss << initial_quote;

    std::string first;
    std::string last;
    std::string language, extracted_quote;

    // >> 提取符按数据流顺序读取字符串的内容，
    // 以空白字符分隔（' ', '\n', '\t'）
    ss >> first >> last >> language >> extracted_quote;

    // 输出
    std::cout << first << "" << last << " said this: " << language << " " << extracted_quote << std::endl; 
}
```

!!! warning

    使用字符串流时 `extracted_quote` 不能一次性把剩余的字符串全部提取出来，因为每一次提取都会按照空白符（包括空格、缩进、换行）进行分割，因此一次只能读取一个单词。

    为了一次性读取一行输入中剩余的内容，应该使用 `getline()` 函数。

#### getline()

函数接口为 `istream& getline(istream& is, string& str, char delim)`

- `getline()`读取一串输入流`is`，直到读取字符`delim`时停止，将读到的数据存入缓冲区`str`中
- `delim` 默认为 `\n`
- `getline()` 读取的数据是会把字符 `delim` “消耗（consumes）” 掉，也会读取这个字符

上面的代码中提取字符的部分修改为以下语句，就可以让`extracted_quote`提取出剩余的字符串：

```cpp
ss >> first >> last >> language;
std::getline(ss, extracted_quote);
```

### 输出流

输出流：一种向目标/外部源写入数据的方法

- 使用 `<<` 运算符“发送”输出流

输出流的字符在被释放（flush）到目的地之前会被存储在一个中间缓冲区内，`std::endl` 除了换行之外，还会立即执行一次 flush 操作

- 一般而言，更建议使用 `\n` 而非 `std::endl`——一定程度上减少 flush 次数以提高性能。

#### 输出文件流

输出文件流（output file streams）的类型为 `std::ofstream`，同样采用 `<<` 插入符将数据送入文件内。

`std::ofstream` 常用的几种方法有

- `is_open()`
- `open()`
- `close()`
- `fail()`

!!! example 

    ```cpp
    int main()
    {
        // 在文件 hello.txt 中创建一个新的输出文件流
        std::ofstream ofs("hello.txt");

        // 检查文件是否打开，若是则将一段字符串写进文件内
        if (ofs.is_open())
        {
            ofs << "Hello CS106L!" << '\n';
        }

        // 关闭文件
        ofs.close();

        // 由于文件已关闭，以下内容不会被写入 hello.txt 中
        ofs << "this will not get written";

        // 重新打开文件
        ofs.open("hello.txt");

        // 下面的字符串又可以被写入文件内，但是会覆盖文件原来的内容
        ofs << "this will though! It's open again";

        return 0;
    }
    ```

### 输入流

输入流 `std::cin` 也同样有缓冲区，它会把输入流数据逐个读入缓冲区内，直到遇到空白字符为止。

考虑下面的代码：

```cpp
int main()
{
    double pi;
    double tao;
    std::string name;

    std::cin >> pi;
    std::cin >> name;
    std::cin >> tao;

    std::cout << "my name is: " << " tao is: " << tao << " pi is: " << pi << '\n';

    return 0;
}
```

`std::cin` 的缓冲区的内容为：

<figure>
    <img src="../assets/输入流缓冲区内容.png" width="100%">
</figure>

我们很容易知道 `pi` 的值为 3.14，`name` 的值为字符串 `"Fabio"`，但类型为 `double` 的 `tao` 由于接收到了类型不匹配的数据 `"Ibanez"`，因此它的值被设置为 0，并抛出了错误信息。事实上我们希望 `name` 的值为完整的字符串 `"Faibio Ibanez"`。

我们不难想到使用 `getline()` 来提取这个完整的字符串。但此时我们只会读取到紧接在 3.14 后面的 `\n`，然后就会因为遇到了换行符而停止向 `name` 读入数据，从而使得在这个 `\n` 后的数据被抛弃掉。

解决办法是连续使用两次 `getline()`：先读取掉第一个换行符，在通过第二次 `getline()` 获取正确的数据

```cpp
std::cin >> pi;
std::getline(std::cin, name);
std::getline(std::cin, name);
std::cin >> tao;
```

这提醒我们在将 `std::cin` 和 `getline()` 混合使用时，我们需要格外注意由于读取规则不同而导致的读取错误，如果可以，应尽量避免将它们混合使用。

#### 输入文件流

输入文件流（input file streams）的类型为 `std::ifstream`，使用 `>>` 提取符从文件中读取数据。它的各种方法输出文件流非常类似：

!!! example

    ```cpp
    int inputFileStreamExample()
    {
        std::ifstream ifs("append.txt");

        if (ifs.is_open())
        {
            std::string line;
            std::getline(ifs, line);
            std::out << "Read from the file: " << line << '\n';
        }

        if (ifs.is_open())
        {
            std::string lineTwo;
            std::getline(ifs, lineTwo);
            std::out << "Read from the file: " << lineTwo << '\n';
        }    

        return 0; 
    }
    ```

## 容器

!!! info

    CS106L 默认学生已经修读（或同时正在修读 CS106B/X），因此它对于各种容器的使用方法没有介绍得很详细，只讲解了少数几个容器的内容，如果希望了解更多关于容器的知识，可以从 [cppreference](https://en.cppreference.com/w/cpp/container) 或其他网络资源了解。

### 几个常见容器及其方法

C++ 许多容器处于 C++ Standard Template Library (STL) 中，所有的 STL 容器都是模板，包括

- `std::vector`
- `std::set`
- `std::stack`
- `std::queue`
- `std::map`
- `std::unordered_map`
- `std::unordered_set`
- `std::priority_queue`
- `std::deque`
- `std::array`


#### vector

- `std::vector<int> vec;`：创建新的空向量
- `std::vector<int> vec(n);`：创建一个包含 n 个 0 的向量
- `std::vector<int> vec(n, k);`：创建一个包含 n 个值 k 的向量
- `vec.push_back(k);`：将 k 加在向量的末端
- `vec.clear();`：移除向量内所有元素
- `int k = vec[i];`：获取索引为 i 的元素（不检查是否索引越界）
- `int k = v.at(i);`：获取索引为 i 的元素（检查是否出现索引越界）
- `vec.size();`：查看向量大小（当前元素个数）
- `vec.capacity()`：查看当前向量容量（当前占据的内存空间可以容纳多少个元素，而不需进行动态内存分配）

#### deque

`deque`（读音为 deck）是双端队列（double-ended queue），除了额外的 `push_front()` 和 `pop_front()` 方法外，它具有与 `std::vector` 几乎完全相同的接口。

#### map

映射（map）中包含多个键值对，方法包括

- `std:::map<int, char> m;`：创建空映射
- `m.insert({k, v});` 或 `m[k] = v;`：将键 k 和对应值 v 加入映射内
- `m.erase(k);`：将键 k 从映射中移除
- `m.count(k)`：检查键 k 是否在映射内，返回布尔值
- `m.empty()`：检查映射是否为空
- `char c = m.at(k); m.at(k) = v; `：检索并覆写键 k 对应的值（若键不存在则**报错**）
- `char c = m[k]; m[k] = v;`：检索并覆写键 k 对应的值（若键不存在则**自动插入**）

`std::map<K, V>` 实际上是一个存储着多个 `std::pair<const K, V>` 的集合。例如，我们可以像下面这样使用：

```cpp
std::map<std::string, int> map;

// 方法1
for (auto kv : map) {
    // kv 类型为 std::pair<const std::string, int>
    std::string key = kv.first;
    int value = kv.second;
}

//方法2
for (const auto& [key, value] : map) {
    // key 的类型为 const std::string&
    // value 的类型为 const int&
}
```

!!! info "map 的实现" 

    `std::map` 在具体的实现上是通过二叉树（技术上是红黑树）来做到的。
    
    由于二叉树在搜索时需要对键值 K 进行比较，因此 K 需要具有比较运算符 `operator<`

    <figure>
        <img src="../assets/map的实现.png" width="80%">
    </figure>

    ```cpp
    // OKAY - int has operator<
    std::map<int, int> map1; 

    // ERROR - std::ifstream has no operator<
    std::map<std::ifstream, int> map2;
    ```

#### set

`std::set` 存储着一系列不同的元素，它相当于一个特殊的、只存储 key 而不保存 value 的 `std::map`。

`std::set` 同样也是通过红黑树实现的，因此它保存的元素也必须能够进行比较，具有 `operator<`

- `std::set<int> s;`：创建空集合
- `s.insert(k)`：将值 k 加入集合内
- `s.erase(k)`：从集合中移除值 k
- `if (s.count(k))`：检查值 k 是否在集合内

    - 从 C++20 开始也可使用 `if (s.contains(k))`

- `if (s.empty())`：检查集合是否为空

#### unordered_map 与 unordered_set

unordered_map 是 map 的一个优化版本，它具有和 map 相同的接口，但是它的实现方式是通过哈希表（hash table）来实现的，因此它的插入、查找、删除等操作的时间复杂度是 O(1)。

<figure>
    <img src="../assets/unordered_map的实现.png" width="80%">
</figure>

!!! tip 

    unordered_map 不再要求 key 必须具有 `operator<`，而是要求 key 必须具有 `operator==` 和 `std::hash`（可以通过 `std::hash` 来计算 key 的哈希值，hashable）。

    ```cpp
    // OKAY - int is hashable
    std::unordered_map<int, int> map1; 

    // ERROR - std::ifstream is not hashable
    std::unordered_map<std::ifstream, int> map2;
    ```

- 荷载因子（load factor）：哈希表中元素的数量与桶的数量之比，当荷载因子超过某个阈值时，哈希表会自动扩容，以保证查询效率。
- 默认的 load factor 为 1，我们也可以通过 `max_load_factor()` 来设置荷载因子的阈值。

    ```CPP
    std::unordered_map<std::string, int> map;

    double lf = map.load_factor(); // Get current load factor
    map.max_load_factor(2.0);      // Set the max load factor
    ```

而 `std::unordered_set` 就相当于一个不含有 values 的 `std::unordered_map`，它的元素也必须是 hashable 的。

!!! note "unordered_map vs. map"

    - unordered_map 通常比 map 更快，但会占据更多的内存空间
    - 如果需要保存的类型没有 `operator<`，则应该使用 unordered_map
    - 相对而言，unordered_map 更加安全



!!! abstract

    |                    | ith element | search | insertion | erase |
    |--------------------|-------------|--------|-----------|-------|
    | std::vector        | 很快         | 慢     | 慢        | 慢     |
    | std::deque         | 快          | 慢      | 慢        | 慢    |
    | std::set           | 慢          | 快      | 快        | 快    |
    | std::map           | 慢          | 快      | 快        | 快    |
    | std::unordered_set | N/A         | 很快    | 很快      | 很快   |
    | std::unordered_map | N/A         | 很快    | 很快      | 很快   |

### 容器的分类

#### 序列容器

序列容器是元素的线性序列，可以通过按顺序访问容器内的元素。

上面介绍过的容器中，`std::vector` 和 `std::deque` 就是序列容器。

!!! info "vector 的内部实现"

    无论何时，`std::vector` 都会分配一块连续的内存空间来存储元素，并且在需要额外的空间时会被分配到一个更大的内存空间，然后将原来的元素复制到新的内存空间中（并释放旧的元素）。

    需要注意的是，vector 所拥有的元素个数（size）和它所分配的内存空间（capacity）是两个不同的概念。

    - 当目前的 capacity 不足以容纳新的元素时（e.g. 在 `v.size()==v.capacity()` 插入一个新元素），vector 会重新分配一块更大的内存空间，并将原来的元素复制到新的内存空间中。

        - 新分配的内存空间的大小取决于编译器，但一般来说会是原来的两倍。

    - 当 capacity 足够时，对 vector 的元素进行增删不会改变 capacity。

        - e.g. 若当前的 capacity 为 8，而 size 为 5，这时删去一个元素，size 变为 4，但 capacity 仍为 8。这样做是为了避免频繁的内存分配和释放。

!!! info "deque 的内部实现"

    `std::deque` 是双端队列（double-ended queue），底层通常由**多个固定大小的内存块（chunks）**组成，这些块在逻辑上是连续的，但在物理内存中不要求连续。每个块的大小由实现定义，例如 GCC 的 libstdc++ 中每个块的大小为 `512 字节 / sizeof(element)`。

    在更上一层的逻辑上，deque 用一个动态数组（称为 map 或 control block）来保存指向各个内存块的指针。这个数组负责管理所有块的地址，类似“索引”的作用。

    - **动态分块分配**：当在头部或尾部插入元素时，如果当前块已满，deque 会分配得到一个新的内存块，并将其地址添加到 map 中。这一过程避免了整体元素的移动，使得两端插入/删除的时间复杂度为 $O(1)$。
    - **map 的扩容**：如果 map 的空间不足以存储新块的指针，map 会重新分配得到一个更大的内存（类似 std::vector 的扩容策略），并将旧指针复制到新位置。此操作的时间复杂度较高（O(n)），但发生频率极低。

    !!! extra "std::deque 的迭代器"

        `std::deque` 的迭代器需要记录以下信息：

        - 当前元素所在的块指针
        - 当前元素在块内的位置
        - 必要时跳转到相邻块

#### 关联容器

特点：

- 容器不必是有序的
- 具有更快的检索速度

!!! info "map 与 set 的内部实现"

    - 映射（map）是由配对（pair）实现的，其中每一个元素都是：`std::pair<const key, value>`
    - 集合（set）相当于只有键、没有值的映射，因此它的元素都是 `const key`


    有序的 map 和 set 的内部是通过红黑树实现的，因此都要求元素的键值具有 `operator<`，以此来进行元素的比较与检索。

    无序的 unordered_map 和 unordered_set 的内部是通过哈希表实现的，因此要求元素的具有运算符 `std::hash` 和 `operator==`，即可哈希化且可比较。

## 迭代器

### 迭代器基本概念

**迭代器**（iterator）是一种对象，它允许我们按照某种特定的顺序在容器中遍历元素，而不需要关心容器的具体实现。

- `c.begin()`：返回指向容器 c 中第一个元素的迭代器
- `c.end()`：返回指向容器 c 中最后一个元素的下一个位置的迭代器（并不是指向最后一个元素）

所有的迭代器都有以下几个基本操作：

- `auto it = c.begin();` 拷贝初始化
- `++it`：迭代器自增
- `*it`：解引用迭代器，获取迭代器指向的元素
- `it == c.end()`：比较操作

但大部分迭代器还会提供一下几种操作：

- `--it`：迭代器自减（反向移动）
- `*it = elem;`：修改迭代器指向的元素
- `it += n;`：迭代器移动 n 个位置
- `it1 < it2`：比较两个迭代器的位置（某个迭代器是否在另一个迭代器之前）

### 迭代器的类型

迭代器的类型决定了它们的功能和行为，C++ 中的迭代器类型大致可以这么划分：

<figure>
    <img src="../assets/迭代器类型1.png" width="80%">
</figure>

- **输入迭代器**（Input Iterators）：绝大部分迭代器的基本类型，允许我们通过迭代器读取元素
- **输出迭代器**（Output Iterator）：允许我们通过迭代器写入（修改）元素
- **前向迭代器**（Forward Iterator）：允许我们在容器中向前遍历元素的输入迭代器
- **双向迭代器**（Bidirectional Iterator）：允许我们在容器中向前和向后遍历元素的输入迭代器
- **随机访问迭代器**（Random Access Iterator）：允许我们在容器中随机访问元素的输入迭代器（可以指定偏移量，而不按顺序迭代）

    - `std::vector` 和 `std::deque` 的迭代器就是随机访问迭代器

<figure>
    <img src="../assets/迭代器类型2.png" width="70%">
</figure>

!!! note "for-each loop 与迭代器"

    for-each loop 本质上在使用迭代器来遍历容器，因此它只能用于支持输入迭代器的容器。

    下面这段代码使用 for-each loop 来遍历一个 vector：

    ```cpp
    std::vector<int> vec = {1, 2, 3, 4, 5};

    for (int elem : vec) {
        std::cout << elem << " ";
    }
    ```

    它的实现方式类似于下面的代码：

    ```cpp
    auto b = vec.begin();
    auto e = vec.end();

    for (auto it = b; it != e; ++it) {
        int elem = *it;
        std::cout << elem << " ";
    }
    ```

## 类

我的 [C++ 笔记](cpplearning.md#类)中已经对关于类的内容有了很多介绍了，这里就只稍微记一些补充的内容。

### 基本概念

!!! quote "结构体和类的区别"

    classes containing a sequence of objects of various typs, a set of functions for manipulating these objects, and a set of restriction on the access of these objects and function;

    structrues which are classes without access restriction;

    <div style="text-align:right">-- Bjarne Stroustrup</div>

在 CS106L 建议我们把类分别定义在 `.h` 和 `.cpp` 文件中，这样可以更好地区分类的声明和实现。

- 头文件（.h）：
    - 定义类的**接口**
    - 包括：类的声明、成员变量、成员函数的原型、类型定义（alias 和 enum 等）、常量等
- 源文件（.cpp）：
    - 定义类的**实现**
    - 包括：成员函数的具体实现、静态成员变量的初始化、可执行代码等

### 继承

继承具有以下特点：

- 动态多态性（dynamic polymorphism）：不同类型的对象
- 拓展性（extensibility）：继承允许我们通过创建具有特定属性的子类来扩展现有类

三种继承方式

| 继承类型 | public | protected | private |
|----------|--------|-----------|---------|
| 派生类中 public 成员的属性 | public | protected | 不可访问 |
| 派生类中 protected 成员的属性 | protected | protected | 不可访问 |
| 派生类中 private 成员的属性 | private | private | 不可访问 |

!!! danger "菱形继承问题（diamond problem）"

    菱形继承问题是指在多重继承中，派生类继承了两个基类，而这两个基类又继承自同一个基类，从而导致派生类中包含了两份相同的基类。

    我们需要使用虚继承（virtual inheritance）来解决这个问题。

    ```cpp
    class A {};
    class B : public A {};
    class C : public A {};
    class D : public B, public C {};
    ```

    在这个例子中，`D` 继承了 `B` 和 `C`，而 `B` 和 `C` 都继承了 `A`，因此 `D` 中包含了两份 `A`。

    为了解决这个问题，我们可以使用虚继承：

    ```cpp
    class A {};
    class B : virtual public A {};
    class C : virtual public A {};
    class D : public B, public C {};
    ```

    这样 `D` 中就只包含了一份 `A`，并且 `D` 要负责调用 `A` 的构造函数（负责初始化基类 `A`）。

## 模板类

!!! tip "类模板与模板类"

    虽然类模板和模板类在名称上非常相似，但它们的含义是不同的：

    - **类模板**（class template）：是一个模板，用于生成类的定义，编译器会使用它来实例化各种具体的类，类似于函数模板用于生成函数定义
    - **模板类**（template class）：是类模板实例化后的具体类。当使用类模板定义对象时，需要指定实际的类型参数，从而生成模板类。

    ```cpp
    // 类模板
    template <typename T>
    class MyClass {
        T data;
    };

    // 模板类
    MyClass<int> myInt;
    ```

由于编译器需要知道模板类中所有成员的定义（包括成员函数的完整定义和实现），因此类模板的声明和实现都需要包含在头文件中，然后在需要使用这个类模板的地方 `#include` 这个头文件。

!!! example "直接在头文件中定义类模板的两种方法"

    === "方法一"

        ```cpp title="myclass.h"
        #ifndef MYCLASS_H
        #define MYCLASS_H

        template <typename T>
        class MyClass {
        public:
            void myFunction();
        };

        void MyClass<T>::myFunction() {
            // Implementation
        }

        #endif
        ```

    === "方法二"

        ```cpp title="myclass.h"
        #ifndef MYCLASS_H
        #define MYCLASS_H

        template <typename T>
        class MyClass {
        public:
            void myFunction() {
                // Implementation
            }
        };

        #endif
        ```

    ```cpp title="main.cpp"
    #include "myclass.h"

    int main()
    {
        MyClass<int> myInt;
        myInt.myFunction();

        return 0;
    }
    ```

!!! info 
    CS106L 给出的观点是，仍然在 `.h` 文件中定义类模板，在 `.cpp` 文件中实现类模板的成员函数，但是要在 `.h` 文件的末尾`#include` 这个 `.cpp` 文件。然后在需要使用这个类模板的地方 `#include` 这个 `.h` 文件即可。

    按照 CS106L 的观点，一个普通的类一般是这么编写的：

    ```cpp title="myclass.h"
    #ifndef MYCLASS_H
    #define MYCLASS_H

    class MyClass {
    public:
        void myFunction();
    };

    ```

    ```cpp title="myclass.cpp"
    #include "myclass.h"

    void MyClass::myFunction() {
        // Implementation
    }
    ```

    而当我们使用类模板时，我们就要：

    ```cpp title="mytemplate.h"
    #ifndef MYTEMPLATE_H
    #define MYTEMPLATE_H

    template <typename T>
    class MyTemplate {
    public:
        T& myFunction();
    };

    #include "mytemplate.cpp"

    ```

    ```cpp title="mytemplate.cpp"
    template <typename T>
    T& MyTemplate<T>::myFunction() {
        // Implementation
    }
    ```

    至于到底是使用哪种方式定义类模板，就见仁见智了。

!!! note "`typename` 与 `class`"

    在模板中，`typename` 和 `class` 是等价的，例如下面四种写法都是等价的；

    ```cpp
    // 写法一
    template <typename K, typename V>
    struct pair;

    // 写法二
    template <class K, class V>
    struct pair;

    // 写法三
    template <typename K, class V>
    struct pair;

    // 写法四
    template <class K, typename V>
    struct pair;
    ```

## 模板函数





















## 函数与 Lambdas





## 运算符重载














## 特殊成员函数


















## 移动语义


















## Optional 与类型安全























## RAII 与智能指针
















