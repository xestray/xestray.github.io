---
    comments: true
    statistics: true
---

# CS106L

!!! info 
    速通 CS106L 2024 Autumn 之后记录的粗略的笔记，主要来自于课程的 slides，一定程度上也是对我的 [C++笔记](/docs/ComputerScience/PL/cpp/cpp.md) 的补充。

    CS106L 的 slides 和 assignments 解答可以在我的仓库 [CS106L-2024-Autumn](https://github.com/xestray/CS106L-2024-Autumn) 中找到。

## 类型与结构体

### 类型

C++ 是**静态类型语言**，在编译时就需要确定每个实体（变量、函数等）的类型，并且它们的类型从被定义之后就不能改变。

**动态类型语言**（如 Python）在运行时才会确定类型，并且在**运行过程中**会不断根据它们当前的值来确定类型。

### 结构体

结构体（struct）是一种用户自定义的，由多个成员变量组成的数据结构。它可以作为函数的参数、返回值，也可以作为容器的元素，从而实现一次传递多个数据。

!!! example "结构体"

    ```cpp
    struct StanfordID {
    string name;    // These are called fields
    int idNumber;
    };

    // Initialize struct
    StanfordID id1;                  
    id.name = "Xestray";    // Access field with ‘.’
    id.idNumber = 114514;

    // List Initialization
    StanfordID id2 = {"Xestray", 114513};
    ```

### std::pair

std::pair 在 <utility> 头文件中定义，是一个模板类，用于存储两个的对象（不一定是相同类型）。可以通过 `first` 和 `second` 来访问其中的元素。

```cpp
std::pair<double, double> point { 1.0, 2.0 };

std::cout << point.first << " " << point.second
```

我们可以直接使用 `std::make_pair` 来创建一个 pair 对象，并使用 auto 来自动推断类型。

```cpp
auto point = std::make_pair(1.0, 2.0);
```

## 初始化与引用

### 初始化

C++ 有三种初始化方式：

- 直接初始化（direct initialization）
- 统一初始化（uniform initialization）
- 结构化绑定（structured binding）

#### 直接初始化

直接初始化有两种形式

```cpp
int num1 = 12.0;
int num2(12.0);
```

C++在直接赋值时不会进行类型检查，这里直接把 double 类型的 12.0 赋值给了 int 类型的变量，会发生窄化转换（narrowing conversion），可能会导致精度的丢失。

#### 统一初始化

统一初始化使用花括号 `{}` 来初始化变量，它可以防止隐式类型转换，也可以避免窄化转换。

```cpp
int num1 {12.0};
float num2 {12.0};
```

12.0 是 double 类型的，因此这里对 `num1` 的初始化会出现编译错误，阻止窄化转换；虽然 `num2` 是 float 类型的，但是因为它们都是浮点类型的数据，double 到 float 的转换是安全的，因此这里不会报错。

统一初始化的优点在于

- 安全性：统一初始化禁止了窄化转换，从而避免出现意料之外的情况
- 一致性：统一初始化可以用于所有类型的初始化场景，包括变量、数组、结构体、类等

#### 结构化绑定

结构化绑定是 C++17 中引入的新特性，允许我们通过结构体、函数的返回值等方式，一次性对多个变量进行初始化。

```cpp
#include <iostream>
#include <string>
#include <tuple>

std::tuple<std::string, std::string, std::string> getClassInfo()
{
    std::string className = "CS106L";
    std::string buildingName = "Thornton 110";
    std::string language = "C++";
    return {className, buildingName, language};
}

int main() {
    auto [className, buildingName, language] = getClassInfo();
    std::cout << "Come to " << buildingName << " and join us for " << className
              << " to learn " << language << "!" << std::endl;

    return 0;
}
```

- 结构化绑定允许我们使用在编译时大小确定的数据结构（如 tuple、pair、array、struct）来一次性初始化多个变量
- 在使用结构化绑定时，我们**只能**使用 `auto` 关键字来自动推断变量的类型

### 引用

引用是某个已经存在的变量的别名，使用 `&` 符号来定义。对某个变量的引用和这个变量的标识符指向的是内存中的同一个地址，因此对引用的操作会直接影响到原变量。

```cpp
int num = 5;
int& ref = num;
ref = 10; // Assigning a new value through the
reference
std::cout << num << std::endl; // Output: 10
```

- 按值传递（pass by value）：函数的参数是一个变量的拷贝，对参数的修改不会影响原变量
- 按引用传递（pass by reference）：函数的参数是原变量的引用，对参数的修改会直接影响原变量

!!! example

    ```cpp
    void square(int& n)
    {
        n = std::pow(n, 2);
    }
    ```

!!! note "左值与右值"

    从字面意思来看，左值就是可以放在赋值运算符左边的值，右值就是只能放在赋值运算符右边的值。但具体来说

    - 左值：是一个具有持久身份、可以取地址的实体，通常对应一个具名对象（变量或引用等）

        - 可以放在赋值运算符左侧（e.g. `int x = 5;`）
        - 有明确的内存地址（可通过 `&` 取地址）
        - 生命周期超过当前表达式

    - 右值：是一个临时的表达式，通常无法取地址，通常对应一个匿名对象或表达式的结果

        - 只能放在赋值运算符右侧（e.g. `10 = a` 非法）
        - 通常是字面量、临时对象或表达式计算结果等
        - 生命周期仅限于当前表达式

## 流（stream）

### 基本概念

**流（stream）**：一种通用的 C++ I/O 抽象，用于读取和写入数据。

- cin：标准输入流，用于读取用户输入
- cout：标准输出流，用于输出信息（无缓冲）
- cerr：标准错误流，用于输出错误信息（无缓冲）
- clog：标准日志流，用于记录非关键事件的日志（有缓冲）

<figure>
    <img src="../assets/CPP_IO库.png" width="70%">
</figure>

#### cout

`std::cout` 流是 `std::ostream` 的一个实例，能将数据输出到控制台上，基本运算符为 `<<`（插入符）。

```cpp
std::cout << "Hello, World" << std::endl;
```

#### cin

`std::cin` 流是 `std::istream` 的一个实例，能从控制台读取数据,基本运算符为 `>>`（提取符）。

```cpp
std::cin >> num;
```

### 字符串流

字符串流（stringstream）可用于处理混合数据类型的情况。

```cpp
int main()
{
    std::string initial_quote = "Bjarne Stroustrup C makes it easy to shoot yourself in the foot";

    // 两种字符串流初始化方式
    // 1. 字符串构造函数
    std::stringstream ss(initial_quote);

    // 2. 插入字符串
    // std::stringstream ss;
    // ss << initial_quote;

    std::string first;
    std::string last;
    std::string language, extracted_quote;

    // >> 提取符按数据流顺序读取字符串的内容，
    // 以空白字符分隔（' ', '\n', '\t'）
    ss >> first >> last >> language >> extracted_quote;

    // 输出
    std::cout << first << "" << last << " said this: " << language << " " << extracted_quote << std::endl; 
}
```

!!! warning

    使用字符串流时 `extracted_quote` 不能一次性把剩余的字符串全部提取出来，因为每一次提取都会按照空白符（包括空格、缩进、换行）进行分割，因此一次只能读取一个单词。

    为了一次性读取一行输入中剩余的内容，应该使用 `getline()` 函数。

#### getline()

函数接口为 `istream& getline(istream& is, string& str, char delim)`

- `getline()`读取一串输入流`is`，直到读取字符`delim`时停止，将读到的数据存入缓冲区`str`中
- `delim` 默认为 `\n`
- `getline()` 读取的数据是会把字符 `delim` “消耗（consumes）” 掉，也会读取这个字符

上面的代码中提取字符的部分修改为以下语句，就可以让`extracted_quote`提取出剩余的字符串：

```cpp
ss >> first >> last >> language;
std::getline(ss, extracted_quote);
```

### 输出流

输出流：一种向目标/外部源写入数据的方法

- 使用 `<<` 运算符“发送”输出流

输出流的字符在被释放（flush）到目的地之前会被存储在一个中间缓冲区内，`std::endl` 除了换行之外，还会立即执行一次 flush 操作

- 一般而言，更建议使用 `\n` 而非 `std::endl`——一定程度上减少 flush 次数以提高性能。

#### 输出文件流

输出文件流（output file streams）的类型为 `std::ofstream`，同样采用 `<<` 插入符将数据送入文件内。

`std::ofstream` 常用的几种方法有

- `is_open()`
- `open()`
- `close()`
- `fail()`

!!! example 

    ```cpp
    int main()
    {
        // 在文件 hello.txt 中创建一个新的输出文件流
        std::ofstream ofs("hello.txt");

        // 检查文件是否打开，若是则将一段字符串写进文件内
        if (ofs.is_open())
        {
            ofs << "Hello CS106L!" << '\n';
        }

        // 关闭文件
        ofs.close();

        // 由于文件已关闭，以下内容不会被写入 hello.txt 中
        ofs << "this will not get written";

        // 重新打开文件
        ofs.open("hello.txt");

        // 下面的字符串又可以被写入文件内，但是会覆盖文件原来的内容
        ofs << "this will though! It's open again";

        return 0;
    }
    ```

### 输入流

输入流 `std::cin` 也同样有缓冲区，它会把输入流数据逐个读入缓冲区内，直到遇到空白字符为止。

考虑下面的代码：

```cpp
int main()
{
    double pi;
    double tao;
    std::string name;

    std::cin >> pi;
    std::cin >> name;
    std::cin >> tao;

    std::cout << "my name is: " << " tao is: " << tao << " pi is: " << pi << '\n';

    return 0;
}
```

`std::cin` 的缓冲区的内容为：

<figure>
    <img src="../assets/输入流缓冲区内容.png" width="100%">
</figure>

我们很容易知道 `pi` 的值为 3.14，`name` 的值为字符串 `"Fabio"`，但类型为 `double` 的 `tao` 由于接收到了类型不匹配的数据 `"Ibanez"`，因此它的值被设置为 0，并抛出了错误信息。事实上我们希望 `name` 的值为完整的字符串 `"Faibio Ibanez"`。

我们不难想到使用 `getline()` 来提取这个完整的字符串。但此时我们只会读取到紧接在 3.14 后面的 `\n`，然后就会因为遇到了换行符而停止向 `name` 读入数据，从而使得在这个 `\n` 后的数据被抛弃掉。

解决办法是连续使用两次 `getline()`：先读取掉第一个换行符，在通过第二次 `getline()` 获取正确的数据

```cpp
std::cin >> pi;
std::getline(std::cin, name);
std::getline(std::cin, name);
std::cin >> tao;
```

这提醒我们在将 `std::cin` 和 `getline()` 混合使用时，我们需要格外注意由于读取规则不同而导致的读取错误，如果可以，应尽量避免将它们混合使用。

#### 输入文件流

输入文件流（input file streams）的类型为 `std::ifstream`，使用 `>>` 提取符从文件中读取数据。它的各种方法输出文件流非常类似：

!!! example

    ```cpp
    int inputFileStreamExample()
    {
        std::ifstream ifs("append.txt");

        if (ifs.is_open())
        {
            std::string line;
            std::getline(ifs, line);
            std::out << "Read from the file: " << line << '\n';
        }

        if (ifs.is_open())
        {
            std::string lineTwo;
            std::getline(ifs, lineTwo);
            std::out << "Read from the file: " << lineTwo << '\n';
        }    

        return 0; 
    }
    ```

## 容器

!!! info

    CS106L 默认学生已经修读（或同时正在修读 CS106B/X），因此它对于各种容器的使用方法没有介绍得很详细，只讲解了少数几个容器的内容，如果希望了解更多关于容器的知识，可以从 [cppreference](https://en.cppreference.com/w/cpp/container) 或其他网络资源了解。

### 几个常见容器及其方法

C++ 许多容器处于 C++ Standard Template Library (STL) 中，所有的 STL 容器都是模板，包括

- `std::vector`
- `std::set`
- `std::stack`
- `std::queue`
- `std::map`
- `std::unordered_map`
- `std::unordered_set`
- `std::priority_queue`
- `std::deque`
- `std::array`


#### vector

- `std::vector<int> vec;`：创建新的空向量
- `std::vector<int> vec(n);`：创建一个包含 n 个 0 的向量
- `std::vector<int> vec(n, k);`：创建一个包含 n 个值 k 的向量
- `vec.push_back(k);`：将 k 加在向量的末端
- `vec.clear();`：移除向量内所有元素
- `int k = vec[i];`：获取索引为 i 的元素（不检查是否索引越界）
- `int k = v.at(i);`：获取索引为 i 的元素（检查是否出现索引越界）
- `vec.size();`：查看向量大小（当前元素个数）
- `vec.capacity()`：查看当前向量容量（当前占据的内存空间可以容纳多少个元素，而不需进行动态内存分配）

#### deque

`deque`（读音为 deck）是双端队列（double-ended queue），除了额外的 `push_front()` 和 `pop_front()` 方法外，它具有与 `std::vector` 几乎完全相同的接口。

#### map

映射（map）中包含多个键值对，方法包括

- `std:::map<int, char> m;`：创建空映射
- `m.insert({k, v});` 或 `m[k] = v;`：将键 k 和对应值 v 加入映射内
- `m.erase(k);`：将键 k 从映射中移除
- `m.count(k)`：检查键 k 是否在映射内，返回布尔值
- `m.empty()`：检查映射是否为空
- `char c = m.at(k); m.at(k) = v; `：检索并覆写键 k 对应的值（若键不存在则**报错**）
- `char c = m[k]; m[k] = v;`：检索并覆写键 k 对应的值（若键不存在则**自动插入**）

`std::map<K, V>` 实际上是一个存储着多个 `std::pair<const K, V>` 的集合。例如，我们可以像下面这样使用：

```cpp
std::map<std::string, int> map;

// 方法1
for (auto kv : map) {
    // kv 类型为 std::pair<const std::string, int>
    std::string key = kv.first;
    int value = kv.second;
}

//方法2
for (const auto& [key, value] : map) {
    // key 的类型为 const std::string&
    // value 的类型为 const int&
}
```

!!! info "map 的实现" 

    `std::map` 在具体的实现上是通过二叉树（技术上是红黑树）来做到的。
    
    由于二叉树在搜索时需要对键值 K 进行比较，因此 K 需要具有比较运算符 `operator<`

    <figure>
        <img src="../assets/map的实现.png" width="80%">
    </figure>

    ```cpp
    // OKAY - int has operator<
    std::map<int, int> map1; 

    // ERROR - std::ifstream has no operator<
    std::map<std::ifstream, int> map2;
    ```

#### set

`std::set` 存储着一系列不同的元素，它相当于一个特殊的、只存储 key 而不保存 value 的 `std::map`。

`std::set` 同样也是通过红黑树实现的，因此它保存的元素也必须能够进行比较，具有 `operator<`

- `std::set<int> s;`：创建空集合
- `s.insert(k)`：将值 k 加入集合内
- `s.erase(k)`：从集合中移除值 k
- `if (s.count(k))`：检查值 k 是否在集合内

    - 从 C++20 开始也可使用 `if (s.contains(k))`

- `if (s.empty())`：检查集合是否为空

#### unordered_map 与 unordered_set

unordered_map 是 map 的一个优化版本，它具有和 map 相同的接口，但是它的实现方式是通过哈希表（hash table）来实现的，因此它的插入、查找、删除等操作的时间复杂度是 O(1)。

<figure>
    <img src="../assets/unordered_map的实现.png" width="80%">
</figure>

!!! tip 

    unordered_map 不再要求 key 必须具有 `operator<`，而是要求 key 必须具有 `operator==` 和 `std::hash`（可以通过 `std::hash` 来计算 key 的哈希值，hashable）。

    ```cpp
    // OKAY - int is hashable
    std::unordered_map<int, int> map1; 

    // ERROR - std::ifstream is not hashable
    std::unordered_map<std::ifstream, int> map2;
    ```

- 荷载因子（load factor）：哈希表中元素的数量与桶的数量之比，当荷载因子超过某个阈值时，哈希表会自动扩容，以保证查询效率。
- 默认的 load factor 为 1，我们也可以通过 `max_load_factor()` 来设置荷载因子的阈值。

    ```CPP
    std::unordered_map<std::string, int> map;

    double lf = map.load_factor(); // Get current load factor
    map.max_load_factor(2.0);      // Set the max load factor
    ```

而 `std::unordered_set` 就相当于一个不含有 values 的 `std::unordered_map`，它的元素也必须是 hashable 的。

!!! note "unordered_map vs. map"

    - unordered_map 通常比 map 更快，但会占据更多的内存空间
    - 如果需要保存的类型没有 `operator<`，则应该使用 unordered_map
    - 相对而言，unordered_map 更加安全



!!! abstract

    |                    | ith element | search | insertion | erase |
    |--------------------|-------------|--------|-----------|-------|
    | std::vector        | 很快         | 慢     | 慢        | 慢     |
    | std::deque         | 快          | 慢      | 慢        | 慢    |
    | std::set           | 慢          | 快      | 快        | 快    |
    | std::map           | 慢          | 快      | 快        | 快    |
    | std::unordered_set | N/A         | 很快    | 很快      | 很快   |
    | std::unordered_map | N/A         | 很快    | 很快      | 很快   |

### 容器的分类







#### 序列容器





#### 关联容器



## 迭代器






## 类






## 模板类






## 模板函数







## 函数与 Lambdas





## 运算符重载



## 特殊成员函数





## 移动语义






## Optional 与类型安全





## RAII 与智能指针


