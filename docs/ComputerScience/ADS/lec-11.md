---
    comments: true
    statistics: true
---

# 近似算法

!!! info "最优化问题"
    整体而言，我们对一个最优化问题的算法有如下三个期望：

    1. 算法要能找到确切的最优解（optimality）
    2. 算法能高效（通常是多项式时间）运行（efficiency）
    3. 算法是通用的，能够解决所有问题（all instances）

然而对于一些问题，例如 NP 完全问题而言，我们目前无法同时做到以上三点，因此我们需要做一些妥协。

- 如果算法舍弃第二个期望，则是用例如回溯等方法在指数时间内解决问题，这对于输入不大的情况是可以接受的
- 如果舍弃第三个期望，我们相当于为问题找到一些容易解决的特例
- 如果舍弃第一个期望，但我们能保证高效找到的解是和真正的最优解“相差不大”的，那么我们称这类算法为**近似算法**

## 基本概念

!!! definition "近似算法"
    假设有某类问题 $\mathcal{I}$（例如背包问题），其中的一个具体实例记为 $I$（如当背包问题的参数给定的时候即为一个实例），且有一个复杂度为多项式的近似算法 $A$。定义：

    - $A(I)$ 为算法 $A$ 在实例 $I$ 上得到的解；
    - $\text{OPT}(I)$ 为实例 $I$ 的最优解。

    考虑 $\mathcal{I}$ 是最小化问题，若存在 $r \geqslant 1$，对任意的 $I$ 都有：
    $$ A(I) \leqslant r \cdot \text{OPT}(I) $$
    那么称 $A$ 为该问题的 $r$-近似算法（即对于任何可能的问题实例，$A$ 给出的解都不会比最优解的 $r$ 倍大）。我们特别关心其中可以取到的最小 $r$，称：
    $$ \rho = \inf\{r : A(I) \leqslant r \cdot \text{OPT}(I), \forall I\} $$
    为 **近似比**（approximation ratio），即算法 $A$ 最紧的近似界。它可以等价定义为：
    $$ \rho = \sup_{\mathcal{I}} \frac{A(I)}{\text{OPT}(I)} $$
    即这个比值在多实例中的比值是最紧的界。反之，如果是最大化问题，那么上述公式改为：
    $$ \rho = \sup_{\mathcal{I}} \frac{\text{OPT}(I)}{A(I)} $$

    将两者合并起来，可以统一写作：

    $$
    \rho = \sup_{\mathcal{I}} \left\{ \frac{\text{OPT}(I)}{A(I)}, \frac{A(I)}{\text{OPT}(I)} \right\}.
    $$

因为 $\text{OPT}(I)$ 通常是未知的，因此对于给定的一类问题 $\mathcal{I}$ 和 算法 $A$，我们很难直接根据定义求出 $A$ 的今次比，因此只能通过 $\text{OPT}(I)$ 的范围来估计一个近似比。以最小化问题为例，确定近似比需要以下两个步骤：

1. 首先寻找到一个 $r > 1$，对于任何实例 $I$，都有 $A(I) \leqslant r \cdot \text{OPT}(I)$（可以首先找到 $\text{OPT}(I) $ 的一个下界 $ \text{LB}(I) \leqslant \text{OPT}(I) $，然后让 $ A(I) \leqslant r \cdot \text{LB}(I) $ 即可）
2. 接下来证明 $r$ 是不可改进的，即对于任意的 $ \varepsilon > 0 $，都存在在一个实例 $ I_\varepsilon $，使得 $ A(I_\varepsilon) \geqslant (r-\varepsilon) \cdot \text{OPT}(I_\varepsilon) $。 

!!! note "近似方案"
    我们设 $|I|$ 代表问题 $I$ 的规模，$f$ 是一个可计算函数，不一定为多项式函数，那么有

    1. PTAS（多项式时间近似方案，Polynomial time approximation scheme）：

        存在算法 A，使得对每一个固定的 $\varepsilon > 0$，对任意的实例 $I$ 都有
        $$ A(I) \leqslant (1+\varepsilon) \cdot \text{OPT}(I) $$

        且算法 $A$ 的运行时间可以被问题规模 $|I|$ 的多项式上界所限制。则称 $A$ 是该问题的一个 PTAS。

        理论上，算法 $A$ 在多项式时间内可以近似：不超过不同的 $\varepsilon$，$A$ 的运行时间的上界也可能不同。例如，如果算法 $A$ 的复杂度为 $O( |I|^{1/\epsilon})$ 甚至 $O(|I|^{\text{exp} (1/\epsilon)})$ 时，这样算法的表现就会很糟糕，因为指数很大。一般可以将 PTAS 的复杂度记为 $ O(|I|^{(1/\epsilon)}) $。

    2.  EPTAS（Efficient PTAS）：
    
        在 PTAS 的基础上，要求算法 $A$ 的复杂度是 $O(|I|^c)$ 的，其中 $c \geqslant 0$是与 $\varepsilon$ 无关的常数。可以将 EPTAS 的复杂度记为 $|I|^{O(1)} f(1/\varepsilon)$。

    3. FPTAS（Fully PTAS）：
    
        在 PTAS 的基础上，要求算法 $A$ 的运行时间关于 $|I|$ 和 $\varepsilon$ 都呈多项式，即可以将 FPTAS 的复杂度记为 $|I|^{O(1)} (1/\varepsilon)^{O(1)}$。

## 一维装箱问题

!!! question "问题描述"
    给定若干个带有尺寸的物品，要求将所有物品放入容量给定的箱子中，使得每个箱子中的物品尺寸之和不超过箱子容量并使所用的箱子数目最少。简单起见，我们一般将上述模型标准化：给定 $n$ 尺寸在 $(0,1]$ 内的物品 $a_1,a_2,\cdots,a_n$，目标是使用数量尽可能少的单位容量箱子装下所有物品，每个箱子中物品尺寸和都不超过 1。

    事实上我们也可以令每个箱子的容量为 $C$，物体的尺寸在 $(0,C]$ 内，但是为了方便起见，我们通常令 $C=1$。

!!! info "定理"
    给定若干个物品，判断它们是否可由两个箱子装下是 NP 完全的。

!!! info "定理"
    对于一维装箱问题，除非 $P=NP$，否则装箱算法不存在多项式算法有小于 $3/2$ 的近似比。

    也就是说不存在一个算法 $A$，使得对于任意实例 $I$，都有 
    $$A(I) \leqslant \alpha \cdot \text{OPT}(I)$$
    其中 $\alpha < 3/2$。

!!! proof 
    使用反证法，如果存在近似比小于 $\frac{3}{2}$ 的多项式时间近似算法 $A$，那么可以用这个算法 $A$ 来解决 NPC 的判断物品是否可以由两个箱子装下的问题。

    - 如果物品可以由两个箱子装下，即 $OPT=2$，则 $A(I) < \frac{3}{2} \cdot 2 = 3$。由于这个近似算法返回的结果一定是一个整数，于是只能有 $A(I) = 2$，这时候近似算法就能告诉我们物品可以由两个箱子装下。
    - 如果物品不可以由两个箱子装下，那么 $OPT \geqslant 3$，因为 $A(I)$ 不可能小于最优解，于是 $A(I)$ 至少为 3，即 $A(I) \geqslant 3$。
    
    但是由于近似比小于$\frac{3}{2}$，所以由 $A(I)$ 反推出来最优解不可能是 2，于是我们就可以通过近似算法的结果来判断出物体是否可以由两个箱子装下。

    于是我们就通过这个<u>多项式时间</u>的近似算法判断出了两个箱子的装箱问题，而这是一个 NPC 问题，于是就只可能 $P=NP$ 。

在装箱问题中，我们一般不关心全部的实例，而关心 $\text{OPT}(I)$ 较大的那些实例。因此定义 “渐近近似比（asymptotic approximation ratio）” 如下：

!!! definition "渐近近似比"
    对于任意常数 $\alpha \geqslant 1$,对于任意实例 $I$，存在常数 $k$，使得
    $$ A(I) \leqslant \alpha \cdot OPT(I) + k $$

    则称所有满足上式的 $\alpha$ 构成的集合的下确界为 $A$ 的渐近近似比。

    $k$ 可以是一个固定的常数，也可以是 $o(OPT(I))$，只需要在 $OPT(I)$ 充分大时 $k/OPT(I) \to 0$ 即可。

!!! quote "吴一航学长的ADS讲义"
    装箱问题中，若所有的物品信息在开始装箱前已知，则它是离线（offline）问题；若初始时物品信息并不全部给出，例如物品在传送带上逐个到达，需要我们即时安排，而我们对未到达物品的信息一无所知，同时做出的决定无法更改，此时称为在线（online）问题。
    
    “近似比”通常用来描述离线问题近似算法的性能。而对于在线问题，一般用“竞争比（competitive ratio）”的概念。近似比的存在来自于计算资源有限，而竞争比的存在来自于对问题信息所知有限。

### Next Fit

Next Fit（NF）算法是一种简单的装箱算法，其思想是：每次遇到一个物品，如果当前打开的箱子有足够的空间，就把这个物体放进去；如果空间不够就把当前箱子关闭（不再接受任何新的物品），然后新开一个箱子把物体放进去。

- Next Fit 有一个特点，就是相邻的两个箱子内的物品大小之和一定大于 1，否则这两个箱子里的物品就应当放进同一个箱子里去。

根据上面的性质，我们可以证明
$$ NF(I) \leqslant 2 \cdot OPT(I) - 1 $$
或
$$ OPT(I) \geqslant \frac{NF(I)+1}{2} $$
也就是说，如果使用 NF 算法得到的箱子数目是 $2M$（或 $2M+1$），那么最优解至少要用到 $M+1$ 个箱子。

!!! proof
    令 $S(B_i)$ 为箱子 $B_i$ 中物品尺寸之和，$S(B_i) \leqslant 1$， $2M$ 为 NF 算法得到的箱子数目。那么有

    $$
    \begin{cases}
        S(B_1) + S(B_2) > 1 \\
        S(B_3) + S(B_4) > 1 \\
        \cdots \\
        S(B_{2M-1}) + S(B_{2M}) > 1
    \end{cases}
    $$

    把上面的 $M$ 个不等式相加，就得到
    $$ \sum_{i=1}^{2M} S(B_i) > M $$

    因此所有物体的大小总和大于 $M$，那么最优解也至少要用到 $M+1$ 个箱子，即 $OPT(I) \geqslant M+1$。

!!! note "NF 算法的近似比"
    实际上 NF 装箱算法的近似比就是 2：我们刚刚得到的 $NF(I) \leqslant 2 \cdot OPT(I) - 1$ 告诉我们近似比不会大于 2.

    我们还可以考虑下面的一个实例：令所有物品的大小为 $\dfrac{1}{2}, \varepsilon ,\dfrac{1}{2}, \varepsilon \cdots$，共有 $M$ 组这样的物品，且 $\varepsilon > 0$ 充分小。那么很显然 NF 算法得到的结果是 $M$，而最优解为 $M/2 +1$。这就告诉我们对于任何的 Next Fit 算法，总能构造一个实例使得它的近似比不能小于 2，近似比的下界是 2.

    综合上面两点我们就知道，NF 算法的近似比就是 2。

很显然 NF 浪费了很多的空间，近似效果并不好，我们可以考虑奇特的方法。

### Any Fit

Any Fit 是一类 Fit 方案，满足如下性质：当物品到达时，除非所有目前打开的箱子都无法装下该物品，才允许打开一个新箱子。包括下面几种：

- **First Fit**（FF）：优先选择最早被打开的箱子填入
- **Best Fit**（BF）：优先选择最满的箱子（剩余空间最小）填入
- **Worst Fit**（WF）：优先选择最空的箱子（剩余空间最大）填入

前面的所有Fit算法都是在线算法。此外，Any Fit 的三种算法都满足相邻两个箱子物品尺寸之和大于 1，因此它们都不会比 NF 差。而前面 NF 的下界实例也适用于 WF，因此 W F和 NF 一样差。

!!! tip "FF vs BF"
    从定义来看 BF 算法似乎比 FF 算法有更高的箱子利用率，但并非总是如此。我们可以考虑下面两个实例，物体的大小分别为

    - 0.5、0.7、0.1、0.4、0.3 

        FF 需要 2 个箱子，BF 需要 3 个箱子

    - 0.5、0.7、0.3、0.5

        FF 需要 3 个箱子，BF 需要 2 个箱子

    这两个例子说明不会存在“BF总比FF好”或者“FF总比BF”好的结论

可以证明的是：

- NF 和 WF 的近似比都是 2
- 而任意的 Almost Any Fit（AAF）算法都可以达到相同的近似比：1.7

~~具体的证明就不写了(×)~~

!!! info "离线算法"
    上面我们说的几种 Fit 都是在线算法，假如我们提前知道了需要装进箱子的所有物品的大小，并允许我们把物体从大到小降序排列，再使用 First Fit，这种方法就叫做 First Fit Decreasing（FFD）。
    
    显然这是一种离线算法，因为要在知道所有的输入的前提下才能排序，我们有两个结论：

    - 绝对近似比 $FFD(I) \leqslant \dfrac{3}{2} OPT(I)$
    - 渐进近似比 $FFD(I) \leqslant \dfrac{11}{9} OPT(I) + \dfrac{6}{9}$

## 0-1 背包问题

### 基础的 2-近似算法

对于分数背包问题，我们可以直接使用贪心算法，使得背包每一单位重量的价值最大化，这样得到的解就是最优解。但是对于 0-1 背包问题，我们可以轻而易举地举出这样的算法的一个反例：

- 有两个物品，第一个物品的价值为 1，重量为 1，第二个物品的价值为 2，重量为 3，背包的容量为 3。我们的贪心策略是让每单位重量的价值最大化，因此贪心算法的选择结果是选择第一个物品，然后就发现不能装下任何其他物品了；但实际上最优解显然是选择第二个物品，这样背包的价值为 2，而贪心算法的解为 1。因此贪心算法并不是最优的。

为了得到近似比，我们需要进一步改进我们的贪心算法：我们有两个贪心策略，其一是根据这里的单位重量的价值（profit density），其二是直接贪心选择最大价值的物品，我们尝试运行两个贪心算法，并选择两者中的最优解，我们可以证明，这样结合后的近似比为 2。设

- $P_{frac}$ 为分数背包问题的最优解；
- $P_{OPT}$ 为0-1背包问题的最优解；
- $P_{greedy}$ 为贪心算法的解；
- $p_{max}$ 为装得下的物品中价值最大的物品的价值；

$$ p_{max} \leqslant P_{greedy} \leqslant P_{OPT} \leqslant P_{frac} $$
上面第一个不等号是因为其中一种贪心策略是按价值从大到小贪心选择，因此价值最大的（当然前提是能放下）物品一定会被选择；第二个不等号是因为贪心策略是一个可行解，一定小于等于最优解。

于是我们的近似比就有上界
$$ \dfrac{P_{OPT}}{P_{greedy}} \leqslant \dfrac{P_{frac}}{P_{greedy}} \leqslant \dfrac{P_{greedy}+p_{max}}{P_{greedy}} = 1 + \dfrac{p_{max}}{P_{greedy}} \leqslant 2 $$
其中第二个不等号的 $P_{frac} \leqslant P_{greedy}+p_{max}$ 是因为按照贪心策略，我们把分数背包问题最优解中那个被分割成分数个的物品舍去了，而这个被舍去的物品价值一定小于等于 $p_{max}$。

下面我们只需要证明 2 的近似比是不可以再被优化的，考虑下面的一个例子

!!! example
    假设背包容量为 4，有 4 个物品，价值分别为 $2+\varepsilon, 2+\varepsilon, 3.5, 4$，重量分别为 $2, 2, 3, 4$，其中 $\varepsilon$ 是一个很小的正数。
    
    两种贪心策略的结果分别是选择第 3 个和第 4 个物品，两者中最好的结果是选择第四个物品，价值为4。而最优解是选择第 1 个和第 2 个物品，总价值为 $4+\varepsilon$。

    因此近似比为 2，不可能进一步优化。

### FPTAS 算法

现在我们讨论一个更美好的算法，即一个可以无限近似的算法。利用动态规划一讲的算法我们知道 0-1背包问题是有伪多项式算法的，即其复杂度是 $O(nC)$ 的，其中 $n$ 是物品的数量，$C$ 是背包的容量。

但我们可以换个角度进行动态规划，我们的数组第二个维度不再是背包的容量，而是价值，即我们原先的数组是 $A[i][c]$ 表达的是前 $i$ 个物品放入容量为 $c$ 的背包的最大价值，现在我们用 $W_{i,v}$ 来表示前 $i$ 个物品放入价值为 $v$ 的背包的最小重量，那么

- 第 $i$ 个物体在背包中，那么 $W_{i,v} = W_{i-1,v-v_i} + w_i$
- 第 $i$ 个物体不在背包中，那么 $W_{i,v} = W_{i-1,v}$

于是就可以得到的递推方程

$$ 
W_{i,v} = 
    \begin{cases} 
    \infty & \text{if } i = 0 \\ 
    W_{i-1,v} & \text{if } v_i > v \\ 
    \min \{ W_{i-1,v}, W_{i-1,v - v_i} + w_i \} & \text{otherwise} 
    \end{cases}
$$

显然，这一动态规划的复杂度是 $O(nV)$ 的，其中 $V$ 是所有物品的价值之和。我们做个简单的变换，设 $v_{max}$ 是所有物品的价值的最大值，那么显然有 $V \leqslant nv_{max}$，因此我们的复杂度是 $O(n^2 v_{max})$ 的。

这时候我们发现，如果 $v_{max}$ 的大小是么我们将得到一个多项式时间的算法。然而并非所有实例都能满足这一条件，因此我们需要对输入的价值做一些技术性的处理，即对输入的所有价值做同比例的缩小，使得 $v_{max}$ 能缩小到 $n$ 的多项式级别

接下来我们就需要确定缩放比例 $b$，将 $v_i$ 的价值等比例缩小到 $\dfrac{v_i}{b}$。

!!! tip 
    - 首先我们给定想要达到的近似比率 $\varepsilon$，那么我们令缩放比例为 $b = \dfrac{\varepsilon v_{max}}{n}$
    - 接着我们把所有价值缩放并且向上取整为 $\lceil v_i/b \rceil$（向下取整也可以，取整是因为我们要把这些价值作为数组的下标）然后运行动态规划算法得到最优解 $v$
    - 这时候我们再把所有的价值放大 $b$ 倍，即 $v_i' = b \lceil v_i/b \rceil$，此时最优解就为 $bv$，于是 $bv$ 就是原问题的一个近似解

可以证明，上述算法是 0-1 背包问题的一个 FPTAS 算法，其复杂度是 $O(n^2 v_{max}/b) = O(n^3/\varepsilon)$ 的，近似比为 $1+\varepsilon$。

## K-Center 聚类问题

!!! question "问题描述"
    输入 $n$ 个点的位置 $s_1, \cdots ,s_n$，以及一个整数 $k$，要求选择 $k$ 个中心，使得所有点中到最近的中心的距离的最大值 $r(C)$ 最小化。

### 思维实验：假设我们已知最优解

假设我们已经知道了最优解 $r(C^*)$，但是这时候我们还是不知道最优解对应的中心放置的位置，如果我们任意放 $k$ 个中心，以 $r(C^*)$ 为半径，我们很有可能还是不能将所有的点都覆盖。

这时候我们可以转换一下思路，如果我们选择 $s$ 为中心，离它最近的最优解中心是 $C_s$，那么 $s$ 到 $C_s$ 的距离不会超过 $r(C^*)$，这时候我们把半径设置为 $2r(C^*)$，这样就可以把最优解中以 $C_s$ 为中心，$r(C^*)$ 为半径的圆内的所有点都覆盖了（因为在这个圆内任意两点之间的距离不会超过 $2r(C^*)$）。

于是我们就得到了一个 2-近似算法（Greedy-2r）：我们知晓最优解 $r(C^*)$ 后，随机选择选择一个点，把以它为中心，$2r(C^*)$ 为半径的所有点都删除，然后再从剩下的点中随机选择第二个中心，以此类推。这样经过 $k$ 次选择后一定不会有任何点被遗漏，而且我们得到的解是最优解的 2 倍。

!!! info "Greedy-2r 算法"
    Greedy-2r 算法在给定最优解 $r(C^*)$ 的情况下是一个 2-近似算法。

### 不使用思维实验的近似算法设计

假如我们不知道最优解 $r(C^*)$，我们能否设计一个近似算法呢？事实上也是可以的：

- ：我们首先从输入点集中随机选取一个点作为第一个中心，加入中心点集 $C$。然后每轮循环在剩余的点中找到一个点 $s$ 的 dist($s$,$C$)最大，即 $s$ 是到现有中心最短距离最大的点，将其加入中心点集 $C$，直到 $C$ 中有 $K$ 个点。这一算法的近似比是 2。

!!! info "Greedy-Kcenter 算法"
    Greedy-Kcenter 算法是一个 2-近似算法。

!!! proof 
    我们用反证法，设最优解为 $r(C^*)$，并假设 Greedy-Kcenter 算法给出的最优解大于 $2r(C^*)$，这说明Greedy-Kcenter 算法结束后，一定存在一个点 $s$ 距离所有的中心的距离大于 $2r(C^*)$，否则所有点都落在某个中心的 $2r(C^*)$ 范围之内，最优解一定不会大于 $2r(C^*)$。
    
    回顾 Greedy-Kcenter 算法的步骤，每一步我们都在选择一个距离现有中心 $C'$ 最远的点，既然 $s$ 每一步都没有被选到，这就说明我们每一步选取的点 $c$ 都有（假设最终的中心为 $C$）
    $$ \text{dist}(c,C') \geqslant \text{dist}(s,C') \geqslant \text{dist}(s,C) > 2r(C^*) $$

    再回顾 Greedy-2r 算法，其中我们每一步删除选择的中心的 $2r(C^*)$ 范围内所有点，然后随机挑选一个剩余点作为中心。而我们前面得到的 $\text{dist}(c,C') > 2r(C^*)$ 表明在我们假设的情况（存在一个点 $s$ 距离所有的中心的距离大于 $2r(C^*)$）下，我们在 Greedy-Kcenter 算法中每一步选择的点也是符合 Greedy-2r 算法的选择条件的，因为每一步都选择的是当前选过的中心 $2r(C^*)$）开外的点。
    
    所以 Greedy-Kcenter 算法选择 $K$ 个点就相当于 Greedy-2r 算法中选择 $K$ 个点，而根据 Greedy-2r 算法的性质，$K$ 步之后我们还剩下点 $s$没有被覆盖，说明真正最优解一定大于 $r(C^*)$，与我们的假设矛盾。证毕。

### 聚类问题的最优近似比

!!! info "定理"
    除非 $P=NP$，否则 K-center 问题不存在 $\rho$-近似算法（$\rho<2$）。

为了证明这一命题，我们需要首先引入一个 NP 完全问题：dominating set问题

- 给定一个图 $G=(V,E)$ 和一个整数 $k$，我们需要判断是否存在一个大小为 $k$ 的集合 $S \subset V$，使得每个点要么在 $S$ 中，要么与 $S$ 中的某个点相邻。

我们现在通过将 dominating set 问题归约到寻找 $\rho$-近似 k-center 问题（（$\rho<2$）来证明上述定理.

**证明：**为了归约，我们给定一个 dominating set 问题的实例 $G = (V,E)$ 和整数 $k$，我们构造一个 k-center 问题的实例：我们将 $G$ 中相邻的点（有边把两个点直接相连）之间的距离设为 1，不相邻的点之间的距离设为 2。

显然的，此时 k-center 问题的解只可能是 1 或 2（因为所有的边长度只有 1 和 2 两种情况），并且存在半径为 1 的解当且仅当 dominating set 问题存在大小为 $k$ 的解（由此我们看出 k-center 问题是 NP 困难的）。现在我们假设存在一个 $\rho$-近似算法 $A$（$\rho<2$）来解决 k-center 问题，则我们有：

- 如果 $A$ 返回的解 $r$ 在 $1⩽r⩽\rho$，则说明存在一个半径为 1 的解（解只有 1 和 2 两种可能，此时不可能是 2），根据我们前面的分析有 dominating set 问题存在大小为 $k$ 的解；
- 如果 $A$ 返回的解 $r$ 在 $2⩽r⩽2\rho$，则说明不存在一个半径为 1 的解，即 dominating set 问题不存在大小为 $k$ 的解。

由于我们的归约是多项式时间的，并且我们可以通过 $A$ 来在多项式时间解决 dominating set 问题，这就说明我们可以在多项式时间内解决 NP 完全的 dominating set 问题，这就说明了 $P=NP$
