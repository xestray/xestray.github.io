---
    comments: true
    statistics: true
    counter: True
---

# 动态规划

!!! quote "动态规划的来由"
    动态规划（Dynamic Programming，DP）是一种用于解决最优化问题的算法设计方法。它通过将复杂问题分解为更简单的子问题，并存储这些子问题的结果，以避免重复计算，并利用这些子问题的结果来快速求解原问题。

    动态规划的基本思想是利用子问题的最优解构造出原问题的最优解。它的由来可以追溯到以下几个关键点：

    - 重叠子问题：许多最优化问题可以分解成重叠的子问题，动态规划通过记录子问题的解来避免重复计算。

    - 最优子结构：如果一个问题的最优解包含其子问题的最优解，则可以通过解决子问题来构造原问题的解。

    - 贝尔曼方程：贝尔曼提出了一个递归关系（即贝尔曼方程），描述了如何通过子问题的解来得到原问题的解。

## 动态规划的引入——爬楼梯问题

!!! question "爬楼梯问题"
    假设你正在爬楼梯。需要爬n阶你才能到达楼顶。每次你可以爬 1 或 2 级台阶，求有多少种不同的方法爬到楼顶？我们要求算法在线性时间内解决这一问题。

我们可以利用中学的排列组合知识来求出这个问题，例如我们可以假设爬 2 级台阶的次数为 0，1，2...，然后计算出每种情况下的爬楼梯方法的排列数，最后再求和。但是这种方法的时间复杂度显然不是线性的，不能满足我们的要求。

我们也可以用回溯的方法来解决这个问题，但是回溯实际上就是枚举每一种可能的方法，但我们实际上并不关心具体要怎么爬，而是关心爬楼梯的方法数，同时回溯的时间复杂度显然也时远大于线性的。

这时候我们可以转换思路，假设我们已经解决了爬到第 $i$ 级台阶的方法数，其中 $i < n$，我们就只需要考虑最后一步怎么爬就可以了。最后一步有爬 1 级台阶或 2 级台阶两种选择，显然，最后一步爬 1 级对应的方法数就是爬 $n-1$ 级台阶对应的方法数，最后一步爬 2 级对应的方法数就是爬 $n-2$ 级台阶对应的方法数两者之和就是我们爬到 $n$ 级台阶的方法数，于是我们可以得到一个递推关系：
$$ f(n) = f(n-1) + f(n-2) $$
这就是我们常见到的斐波那契数列的递推公式，我们只需要带入初始条件 $f(0) = f(1) = 1$ 就可以很轻松地得到爬楼梯的方法数。

```c
int f(int n) {
    if (n <= 1) return 1;
    else return f(n-1) + f(n-2);
}
```

但是我们知道假如直接用上面这段递归代码来解决这个问题，会出现极大量的冗余计算，同一个斐波那契数列的值会被计算多次，冗余计算次数的增长是爆炸性的，这显然是不合理的。

一个很自然的想法就是我们可以用一个数组来存储已经计算过的每一步的值，这样我们就可以避免重复计算，这是一种很常见的”空间换时间“的算法，想我们称其为“记忆化”，实际上这就是动态规划的基本思想。

```c
int f(int n) {
    if (n <= 1) return 1;

    int dp[n+1];
    dp[0] = dp[1] = 1;

    for (int i = 2; i <= n; i++) 
        dp[i] = dp[i-1] + dp[i-2];

    return dp[n];
}
```

换句话说，原先递归的方法实际上是一种“自顶向下” 的方法，它符合我们的直接思路：最后长度为 n 的问题需要长度为 n−1 和 n−2 的求和，那我们的代码直接利用递归计算递归式显得非常自然。但是重复的计算迫使我们放弃这种自然的想法，转而采用自底向上从小问题逐步迭代构建原问题的解法。

!!! summary
    在爬楼梯这一简单而经典的问题中，我们通过对最后一步两种情况的分类，将整个问题的解转化为了两个子问题解的求和，即有一个从子问题的解到原问题的解的递推公式，然后我们通过记忆化的方式求解递推式。我们将上述特点抽象出来：一个问题，它的最优解可以表达为一些合适的子问题的最优解的递推关系，则我们称这一问题具有最优子结构性质（因为大问题的最优解可以直接依赖于小问题的最优解）。然后我们求解这一递推式，通过设置好 base case（这里我们也用 base case 指代最简单的情况，但注意这时不是递归了），然后通过记忆化的方法，使用迭代算法而非费时的递归算法避免冗余计算，得到一个时间复杂度令人满意的算法，这就是动态规划的基本想法。

!!! info "动态规划"
    动态规划方法通常用来求解最优化问题（optimization problem）。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。我们称这样的解为问题的一个最优解（an optimal solution），而不是最优解（the optimal solution），因为可能有多个解都可以达到最优值。

    我们通常按如下4个步骤来设计一个动态规划算法：
    
    1. 刻画一个最优解的结构特征；
    2. 递归地定义最优解的值；
    3. 计算最优解的值，通常采用自底向上的方法；
    4. 利用计算出的信息构造一个最优解。

    步骤 1-3 是动态规划算法求解问题的基础。如果我们仅仅需要一个最优解的值，而非解本身，可以忽略步骤 4。

    更精炼地来说，事实上动态规划就是为一个具有最优子结构性质（即原问题最优解可以由子问题最优解递推得到）的最优化问题，寻找一个由子问题到原问题的递推式，然后用记忆化的方法来求解。有时在最后我们需要构造出这一最优解，即执行步骤 4，这就需要我们在执行步骤 3 的过程中维护一些额外信息，以便用来构造一个最优解。

## 加权独立集合问题

### 问题描述

!!! question "打家劫舍"
    你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警（也就是说，不能连续偷两个相邻的房屋）。给定一个非负整数数组，代表每个房屋存放金额的数量，计算你在不触动警报装置的情况下，一夜之内能够偷窃到的最高金额数。

我们可以将这个问题抽象出来：

考虑一个无向图 G，其上所有点都在一条线上（这种图我们称其为路径图），每个点都有一个非负权重。我们称 G 的独立集合是指顶点互不相邻的子集（换句话说独立集合中不会同时包含同一条边上的两个点），然后要求解一个具有最大顶点权重和的独立集合。

??? example 
    <figure>
        <img src="../assets/加权独立集合.png" width="65%">
    </figure>
    在上图的这个这个例子中有 8 个独立子集：
    
    - 空集
    - 四个单点集
    - 第 1 和第 3 个点
    - 第 1 和第 4 个点
    - 第 2 和第 4 个点

    其中最大的独立集合显然是第 2 和第 4 个点构成的集合，其权重和为 8，即小偷的最优选择是偷 2 和 4 两家，，最大收益是 8。需要注意的是，题目的假设中每个顶点都有非负权重，所以最优解的顶点应当是越多越好。

### 最优子结构

为了构建出这一问题的最优子结构，我们可以参考爬楼梯问题的思路，先考虑由 $n$ 个点，$n-1$ 条边构成的图 $G(V,E)$ 的最后一个顶点 $v_n$，考虑这个问题的最优解，那么

- 假如 $v_n$ 不在最优解 $S$ 中，那么 $G_n$ 的最优解就是子问题 $G_{n-1}$ 的最优解。

    因为如果 $S$ 不是 $G_{n-1}$ 的最优解，那么对于 $G_{n-1}$ 就会存在一个比 $S$ 更好的解 $S^*$。而 $S^*$ 显然一定是 $G_n$ 的一个可行解，把这个解直接应用到 $G_n$ 中就会得到一个比 $S$ 更好的结果，这和 $S$ 是最优解是矛盾的。因此 $S$ 就是 $G_{n-1}$ 的最优解

- 假如 $v_n$ 在最优解 $S$ 中，那么 $G_n$ 的最优解就是子问题 $G_{n-2}$ 的最优解。

    因为 $v_n$ 在最优解中，那么 $v_{n-1}$ 就一定不在最优解中了，具体的分析与第一种情况类似，

通过上面的分析，我们就可以知道得到一个递推关系，假设前 $i$ 个顶点的最优加权独立
集合的权重之和为 $W_i$，那么
$$ W_i =max{W_{i−1}, W_{i−2} + w_i} $$
其中 $i = 2, 3, \cdots, n, \quad W_0 = 0$

接下来我们可以通过之前介绍的记忆化方法，从 base case 出发，自底向上构建出整个问题的解

<figure>
    <img src="../assets/加权独立问题最优子结构.png" width="70%">
</figure>

很显然，这一算法的时间复杂度是O(n)，是一个非常高效的算法

### 解的重构

有时候我们可能不仅需要最优解的值，还需要最优解本身包含了哪些点，这就需要解的重构。

事实上这一问题想要重构出解非常简单，我们只需要观察上面伪代码的数组 A 给我们留下的线索，自顶向下一步步推断当前图中的最后一个点是否在最优解中。

<figure>
    <img src="../assets/加权独立问题解的重构.png" width="70%">
</figure>

## 背包问题



## 矩阵乘法的计算顺序



## 最优二叉搜索树



## 最短路问题再讨论








































































